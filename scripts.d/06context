#!/bin/sh
#===========================
#FOR:BUILD
#===========================

require_versioned_package curl ${CURL_STRONG_VERSION}

#===========================
#FOR:RUN
#===========================

USER_DATA=/user-data
UCONTEXT_TMP=/ucontext
UCONTEXT_SRC="(none)"
UCONTEXT_TIMEOUT=2
UCONTEXT_TIMEOUT_DATA=10
UCONTEXT_RETRIES=2


# Function to analyze output from portprobe.c, if bit(specific IP address) = 1, connected 
# input args: output from portprobe.c, index of the IP address
is_bit_set() {  
  output=$1
  index_server=$2
  shift_left=$((1-$index_server))
  let "output <<= $shift_left"
  let "output &= 2"
  if [[ $output == 0 ]]; then
    return 1
  else
    return 0
  fi
}


fetch_configdrive() {
  mkdir -p /context_mount
  for P in $(cat /proc/partitions | tail -n+3 | awk '{print $4}' | sort); do
    filesystem=$(blkid /dev/$P | grep -o TYPE=[^\ ]* | tr -d '"' | cut -d= -f2)
    echo "  looking for ISO/FAT image at /dev/$P ($filesystem)" >> /var/log/context.log
    if [ "x$filesystem" = "xiso9660" -o "x$filesystem" = "xvfat" ]; then
      mount -o ro -t $filesystem /dev/$P /context_mount >/dev/null 2>&1
      if [ $? -eq 0 ]; then
        if cp /context_mount/openstack/latest/user_data ${USER_DATA} 2>/dev/null; then
          UCONTEXT_SRC="ConfigDrive"
          umount /context_mount
          break
        fi
        umount /context_mount
      fi
    fi
  done
  rmdir /context_mount
}


fetch_opennebula() {
  mkdir -p /context_mount
  for P in $(cat /proc/partitions | tail -n+3 | awk '{print $4}' | sort); do
    filesystem=$(blkid /dev/$P | grep -o TYPE=[^\ ]* | tr -d '"' | cut -d= -f2)
    echo "  looking for ISO/FAT image at /dev/$P ($filesystem)" >> /var/log/context.log
    if [ "x$filesystem" = "xiso9660" -o "x$filesystem" = "xvfat" ]; then
      mount -o ro -t $filesystem /dev/$P /context_mount >/dev/null 2>&1
      if [ $? -eq 0 ]; then
        if [ -f /context_mount/context.sh ]; then
          ( source /context_mount/context.sh && echo ${EC2_USER_DATA} ) | base64 -d > ${USER_DATA}
          UCONTEXT_SRC="OpenNebula"
          umount /context_mount
          break
        fi
        umount /context_mount
      fi
    fi
  done
  rmdir /context_mount
}


fetch_vsphere() {
  mkdir -p /context_mount
  for P in $(cat /proc/partitions | tail -n+3 | awk '{print $4}' | sort); do
    filesystem=$(blkid /dev/$P | grep -o TYPE=[^\ ]* | tr -d '"' | cut -d= -f2)
    echo "  looking for ISO image at /dev/$P ($filesystem)" >> /var/log/context.log
    if [ "x$filesystem" = "xiso9660" ]; then
      mount -o ro -t $filesystem /dev/$P /context_mount >/dev/null 2>&1
      if [ $? -eq 0 ]; then
        if cp /context_mount/user-data.txt ${USER_DATA} 2>/dev/null; then
          UCONTEXT_SRC="vSphere"
          umount /context_mount
          break
        fi
        umount /context_mount
      fi
    fi
  done
  rmdir /context_mount
}


fetch_azure() {
  mkdir -p /context_mount
  for P in $(cat /proc/partitions | tail -n+3 | awk '{print $4}' | sort); do
    filesystem=$(blkid /dev/$P | grep -o TYPE=[^\ ]* | tr -d '"' | cut -d= -f2)
    echo "  looking for ISO image at /dev/$P ($filesystem)" >> /var/log/context.log
    if [ "x$filesystem" = "xudf" ]; then
      mount -o ro -t $filesystem /dev/$P /context_mount >/dev/null 2>&1
      if [ $? -eq 0 ]; then
        if [ -f /context_mount/E6DA6616-8EC4-48E0-BE93-58CE6ACE3CFB.tag ]; then
          UCONTEXT_SRC="Azure"
          AZURE_ISO="/dev/$P"
          cat /context_mount/CustomData.bin > ${USER_DATA} 2>/dev/null
          umount /context_mount
          break
        fi
        umount /context_mount
      fi
    fi
  done
  rmdir /context_mount
}


fetch_rhevm() {
  :
}

download_userdata() {
  local server=$1
  local url=$2
  local meta_url=$3
  local extra_header="$4"
  local extra_header_opt=
  [ "x${extra_header}" != "x" ] && extra_header_opt="-H"
  local retval

  if [ "x${extra_header}" != "x" ]; then
    echo "  downloading: curl -f -s -o ${USER_DATA} ${extra_header_opt} ${extra_header} --connect-timeout ${UCONTEXT_TIMEOUT_DATA} $url" >> /var/log/context.log
    curl -f -s -o ${USER_DATA} ${extra_header_opt} "${extra_header}" --connect-timeout ${UCONTEXT_TIMEOUT_DATA} $url
    retval=$?
  else
    echo "  downloading: curl -f -s -o ${USER_DATA} --connect-timeout ${UCONTEXT_TIMEOUT_DATA} $url" >> /var/log/context.log
    curl -f -s -o ${USER_DATA} --connect-timeout ${UCONTEXT_TIMEOUT_DATA} $url
    retval=$?
  fi
  if [ $retval -eq 0 ]; then
    return 0
  else
    rm -f ${USER_DATA}
  fi

  # Check if there are meta-data but no user data
  if [ "x$meta_url" != "x" ]; then
    if [ "x${extra_header}" != "x" ]; then
      echo "  downloading: curl -f -s -o ${USER_DATA} ${extra_header_opt} ${extra_header} --connect-timeout ${UCONTEXT_TIMEOUT_DATA} $meta_url" >> /var/log/context.log
      curl -f -s -o ${USER_DATA} ${extra_header_opt} "${extra_header}" --connect-timeout ${UCONTEXT_TIMEOUT_DATA} $meta_url
      retval=$?
    else
      echo "  downloading: curl -f -s -o ${USER_DATA} --connect-timeout ${UCONTEXT_TIMEOUT_DATA} $meta_url" >> /var/log/context.log
      curl -f -s -o ${USER_DATA} --connect-timeout ${UCONTEXT_TIMEOUT_DATA} $meta_url
      retval=$?
    fi
    if [ $retval -eq 0 ]; then
      cat /dev/null > ${USER_DATA}
      return 0
    else
      rm -f ${USER_DATA}
    fi
  fi
  
  # Failure
  return 1
}

fetch_gce() {
  download_userdata 169.254.169.254 \
    http://169.254.169.254/computeMetadata/v1/instance/attributes/user-data \
    http://169.254.169.254/computeMetadata/v1/instance/id \
    "X-Google-Metadata-Request: True"
  [ $? -eq 0 ] && UCONTEXT_SRC="GCE" 
}

fetch_ec2() {
  download_userdata 169.254.169.254 \
    http://169.254.169.254/2009-04-04/user-data \
    http://169.254.169.254/2009-04-04/meta-data/ami-id
  [ $? -eq 0 ] && UCONTEXT_SRC="EC2"
}


fetch_openstack() {
  download_userdata 169.254.169.254 \
    http://169.254.169.254/openstack/2013-10-17/user_data \
    http://169.254.169.254/openstack/2013-10-17/meta_data.json
  if [ $? -eq 0 ]; then
    UCONTEXT_SRC="OpenStack"
  else
    download_userdata 169.254.169.254 \
      http://169.254.169.254/latest/user-data \
      http://169.254.169.254/latest/meta-data/ami-id
    [ $? -eq 0 ] && UCONTEXT_SRC="OpenStack"
  fi
}


fetch_cloudstack() {
  download_userdata 10.1.1.1 \
    http://10.1.1.1/latest/user-data \
    http://10.1.1.1/latest/meta-data/instance-id
  if [ $? -eq 0 ]; then
    UCONTEXT_SRC="CloudStack"
  else
    local dhcp_server=$(cat /var/lib/dhcp-server)
    if [ "x${dhcp_server}" != "x" ]; then
      download_userdata $dhcp_server \
        http://${dhcp_server}/latest/user-data \
        http://${dhcp_server}/latest/meta-data/instance-id
      [ $? -eq 0 ] && UCONTEXT_SRC="CloudStack"
    fi
  fi
}


glideinwms_detect() {
  local user_data="$1"

  if [ "x$_UCONTEXT_USEGLIDEINWMS" = "x0" ]; then
    echo "glideinWMS autodetect disabled by configuration, skipping" >> /var/log/context.log
    return 1
  fi
  
  if [ $(cat ${user_data} | wc -l) -gt 1 ]; then
    # Too many lines, glideinwms user-data is a single line
    return 1
  fi

  if ! grep -q '[^#]*#### -cluster [0-9]* -subcluster [0-9]*####[^#\n]*' ${user_data}; then
    # Wrong format
    return 1
  fi

  return 0
}


if [ ! -b "${ROOT_DEV}" ]; then
  log_start "Contextualizing VM..."
  
  while true; do
    # Start with contextualization sources that don't require network
    for data_source in configdrive opennebula vsphere azure rhevm; do
      echo "looking for user data at $data_source" >> /var/log/context.log
      fetch_${data_source}
      [ -f ${USER_DATA} ] && break 2
    done

    dhcp_server_present=0
    connection_output= 
    local dhcp_server=$(cat /var/lib/dhcp-server)
    if [ "x${dhcp_server}" != "x" ]; then
      dhcp_server_present=1
      connection_output="$(portprobe 169.254.169.254 10.1.1.1 ${dhcp_server} ${UCONTEXT_TIMEOUT})"
    else
      connection_output="$(portprobe 169.254.169.254 10.1.1.1 ${UCONTEXT_TIMEOUT})"
    fi

    # Check connection for EC2 compabtible server and proceed if connected
    if is_bit_set $connection_output 0; then
      for data_source in openstack gce ec2; do
        echo "looking for user data at $data_source" >> /var/log/context.log
        fetch_${data_source}
        [ -f ${USER_DATA} ] && break 2
      done
    fi

    # Check connection for CloudStack endpoint
    if is_bit_set $connection_output 1 -o is_bit_set $connection_output 2; then
      for data_source in cloudstack; do
        echo "looking for user data at $data_source" >> /var/log/context.log
        fetch_${data_source}
        [ -f ${USER_DATA} ] && break 2
      done
    fi

    break
  done

  if [ -f ${USER_DATA} ]; then
    echo "found user data at $UCONTEXT_SRC" >> /var/log/context.log
    # Try to unzip
    cat ${USER_DATA} | gzip -d 2>/dev/null > ${USER_DATA}~
    if [ $? -eq 0 ]; then
      echo "unzipped user data" >> /var/log/context.log
      mv ${USER_DATA}~ ${USER_DATA}
    else
      rm -f ${USER_DATA}~
    fi
    cat ${USER_DATA} | parse_user_data > ${UCONTEXT_TMP}

    . ${UCONTEXT_TMP}

    # CMS currently cannot generate ucernvm context snippets.
    # Parse cvmfs settings from glidein proxy
    if glideinwms_detect ${USER_DATA}; then
      glidein_startup="$(cat ${USER_DATA} | cut -d'#' -f 1 | base64 -d | grep ^args | head -n 1)"
      cernvm_cms_proxy="$(echo $glidein_startup | grep param_CERNVM_CMS_PROXY | sed -r 's/.* -param_CERNVM_CMS_PROXY ([^ ]+).*/\1/' | sed 's/.semicolon,/;/g' | sed 's/\.colon,/:/g' | sed 's/.pipe,/|/g' | sed 's/.minus,/-/g' | sed 's/.dot,/./g')"
      cernvm_pac_urls="$(echo $glidein_startup | grep param_CERNVM_CMS_PAC_URLS | sed -r 's/.* -param_CERNVM_CMS_PAC_URLS ([^ ]+).*/\1/' | sed 's/.semicolon,/;/g' | sed 's/\.colon,/:/g' | sed 's/.pipe,/|/g' | sed 's/.minus,/-/g' | sed 's/.dot,/./g')"
      if [ x"$cernvm_cms_proxy" != "x" ]; then
        echo "applying cvmfs settings (proxy) from glideinWMS user data" >> /var/log/context.log
        echo "_UCONTEXT_CVMFS_HTTP_PROXY=${cernvm_cms_proxy}" >> ${UCONTEXT_TMP} 
      fi
      if [ x"$cernvm_pac_urls" != "x" ]; then
        echo "applying cvmfs settings (pac urls) from glideinWMS user data" >> /var/log/context.log
        echo "_UCONTEXT_CVMFS_PAC_URLS=${cernvm_pac_urls}" >> ${UCONTEXT_TMP}
      fi

      # This can be picked up later on
      cp ${USER_DATA} /glideinwms-user-data

      # Parse again with extracted proxy information
      . ${UCONTEXT_TMP}
    fi
  fi
  
  log_info ${UCONTEXT_SRC}
fi


############################################################
# CLUSTER CONTEXTUALIZATION SECTION

CLUSTER_SERVICE_URL_DEFAULT=https://cernvm-online.cern.ch
# This file has to be created by previous steps
CONTEXT_FILE=${USER_DATA}
# Busybox binary
BBOX=busybox

# How many times we try to connect to the service
# A try every ~30s * 50 = ~25minutes
MAX_TRIES=50
# Sleep time in seconds between each try
SLEEP_TIME_BETWEEN_REQUESTS=25
# Key name under which the master stores its IP in the contextualization service
MASTER_IP_FIELD=master_ip
# Key name under which the master stores its ready status in the contextualization service
READY_STATUS_KEY_FIELD=master_ready
# Item name in the context file (in the ucernvm section)
CLUSTER_SERVICE_URL_FIELD=cvm_service_url
CLUSTER_MASTER_CONTEXT_FIELD=cvm_cluster_master
CLUSTER_PIN_CONTEXT_FIELD=cvm_cluster_pin
# Pattern in the context file, which gets replaced by the fetched data
PLACECEHOLDER_REPLACEMENT=###MASTER_IP_PLACEHOLDER###

# Return cluster_pin from the context file
get_cluster_pin_from_context() {
    # Check if the context file has cluster_pin inside ucernvm section
    # sed prints all lines  in the [ucernvm-*] section, grep greps the cluster_pin line
    local PIN_LINE=
    PIN_LINE=$( sed -n '/\[ucernvm-begin\]/,/\[ucernvm-end\]/p' "$CONTEXT_FILE" 2>/dev/null | grep "$CLUSTER_PIN_CONTEXT_FIELD=" )
    if [ $? -ne 0 ]; then
        echo "" # Does not have cluster_pin
        return 1
    fi

    # erase the first occurence of 'cvm_cluster_pin=' from the grepped pin line
    local CLUSTER_PIN=
    CLUSTER_PIN=$( echo "$PIN_LINE" | sed -e "s/$CLUSTER_PIN_CONTEXT_FIELD=//1" )
    echo "$CLUSTER_PIN"
}

# Return cluster contextualization URL: either from the context file or the default value
get_service_url() {
    # Check if the context file has cluster_service_url inside ucernvm section
    # sed prints all lines  in the [ucernvm-*] section, grep greps the cluster_pin line
    local URL_LINE=
    URL_LINE=$( sed -n '/\[ucernvm-begin\]/,/\[ucernvm-end\]/p' "$CONTEXT_FILE" 2>/dev/null | grep "$CLUSTER_SERVICE_URL_FIELD=" )
    if [ $? -ne 0 -o ! $URL_LINE ]; then
        echo "$CLUSTER_SERVICE_URL_DEFAULT" # Does not have cluster_service_url, using default
        return 0
    fi

    # Erase the first occurence of 'cluster_service_url=' from the grepped pin line
    local SERVICE_URL=
    SERVICE_URL=$( echo "$URL_LINE" | sed -e "s/$CLUSTER_SERVICE_URL_FIELD=//1" )
    if [ "$SERVICE_URL" ]; then
        echo "$SERVICE_URL"
    else
        echo "$CLUSTER_SERVICE_URL_DEFAULT" # empty field, using default
    fi
}

# Create a marker file indicating that contextualization has been done
create_ami_marker_file() {
    # We create it in a root directory, from where it gets transfered to
    # the /mnt/.rw/context directory during the 13context_epilog phase
    touch /ami-contextualized
}

# Check if the marker file exists or the context file is not available
marker_file_exists() {
    if [ -f /mnt/.rw/context/ami-contextualized -o ! -f "$CONTEXT_FILE" ]; then
        return 0
    else
        return 1
    fi
}

############################################################
# MASTER PART

# Do a master contextualization (get IP and push it to the server)
master_contextualization() {
    local CLUSTER_PIN=$( get_cluster_pin_from_context )
    if [ "x$CLUSTER_PIN" = "x" ]; then
        log_start "Context file does not have a cluster pin\n"
        return 1
    fi

    local SERVICE_URL=$( get_service_url )

    log_start "Master cluster contextualization: setting master keys"

    # Extract the ip address of the master
    INTERFACE_NAME=$( $BBOX ifconfig | head -n 1 | cut -d: -f1 | awk '{print $1}' )
    IP_ADDRESS=$( $BBOX ifconfig $INTERFACE_NAME | grep 'inet addr' | cut -d: -f2 | awk '{print $1}' )
    if [ $? -ne 0 -o "x$IP_ADDRESS" = "x" ]; then
        log_fail
        log_warn "Unable to get the IP address of this machine\n"
        return 1
    fi
    DATA=$( echo "{ \"key\": \"$MASTER_IP_FIELD\", \"value\": \"$IP_ADDRESS\" }" )

    local CURL_HEADERS="-H Content-Type:application/json"

    #@- == take data from stdin, ignore output and print only the response status code
    local CURL_CMD="curl -s -o /dev/null -w %{http_code} -XPOST $CURL_HEADERS -d @- $SERVICE_URL/api/clusters/$CLUSTER_PIN/keys"

    local cnt=0
    local status_code=
    while [ $cnt -lt $MAX_TRIES ]; do
        status_code=$( echo "$DATA" | $CURL_CMD )
        if [ "x$status_code" = "x201" ]; then
            break  # success
        fi
        cnt=$(($cnt+1))
        local rand=$( grep -m1 -ao '[0-9]' /dev/urandom | head -n1 ) # get 0-9
        sleep $(( $SLEEP_TIME_BETWEEN_REQUESTS + $rand )) #add 10s jitter
    done

    if [ "x$status_code" = "x201" ]; then
        log_ok
        log_start "Master IP address successfully pushed to the server\n"
        return 0
    else
        log_fail
        log_warn "Unable to push the master IP address to the server\n"
        return 1
    fi
}

############################################################
# SLAVE PART

slave_contextualization() {
    local CLUSTER_PIN=$( get_cluster_pin_from_context )
    if [ "x$CLUSTER_PIN" = "x" ]; then
        log_start "Context file does not have a cluster pin\n"
        return 1
    fi

    local SERVICE_URL=$( get_service_url )

    # Poll the API until the master becomes available (field 'master_ready' appears)

    local CURL_HEADERS="-H Accept:text/plain"
    # Output format: Content_of_the_reply\n\nstatus_code_number
    local CURL_CMD_TEMPLATE="curl -s -w \n\n%{http_code} -XGET"

    # Get the 'master ready' status
    local CURL_CMD="$CURL_CMD_TEMPLATE $SERVICE_URL/api/clusters/$CLUSTER_PIN/keys/$READY_STATUS_KEY_FIELD $CURL_HEADERS"

    # Polling the server for 'master ready' status
    log_start "Polling the server for 'master ready' status"

    local response=
    local cnt=0
    while [ $cnt -lt $MAX_TRIES ]; do
        # Analyze the HTTP response status code only (ignoring the output): we expect the master is ready, when this key is pushed
        response=$( $CURL_CMD )
        local status_code=
        status_code=$( echo "${response}" | tail -n 1 )  # get the last line with status code
        response=$( echo "${response}" | head -n -2 )  # get everything except the last line
        if [ "x$status_code" = "x200" ]; then
            break  # success, then 'master_ready' key exists
        fi
        # Sleep for a while and then try again
        cnt=$(($cnt+1))
        local rand=$( grep -m1 -ao '[0-9]' /dev/urandom | head -n1 ) # get 0-9
        sleep $(( $SLEEP_TIME_BETWEEN_REQUESTS + $rand )) #add 10s jitter
    done

    if [ $cnt -eq $MAX_TRIES ]; then
        log_fail #unable to get 'master_ready' from the server
        return 1
    fi
    log_ok

    # Get the master IP address
    log_start "Getting the master IP address from the server"

    CURL_CMD="$CURL_CMD_TEMPLATE $SERVICE_URL/api/clusters/$CLUSTER_PIN/keys/$MASTER_IP_FIELD $CURL_HEADERS"

    response=
    cnt=0
    while [ $cnt -lt $MAX_TRIES ]; do
        # Return HTTP response status code only (ignoring the output)
        response=$( $CURL_CMD )
        local status_code=
        status_code=$( echo "${response}" | tail -n 1 )  # get the last line with status code
        response=$( echo "${response}" | head -n -2 )  # get everything except the last line
        if [ "x$status_code" = "x200" ]; then
            break  # success
        fi
        # Sleep for a while and then try again
        cnt=$(($cnt+1))
        local rand=$( grep -m1 -ao '[0-9]' /dev/urandom | head -n1 ) # get 0-9
        sleep $(( $SLEEP_TIME_BETWEEN_REQUESTS + $rand )) #add 10s jitter
    done

    if [ $cnt -eq $MAX_TRIES ]; then
        log_fail #unable to get required values from the server
        return 1
    fi

    #Erase the 'key: ' part from the response
    local masterIp=
    masterIp=$( echo "$response" | sed "s/$MASTER_IP_FIELD: //g" )
    sed -i "s/$PLACECEHOLDER_REPLACEMENT/$masterIp/g" $CONTEXT_FILE 2>/dev/null
    log_ok
    log_start "Replaced the IP placeholder with: $masterIp"
    log_ok
}

contextualization() {
    marker_file_exists && return 0  # Contextualization has run before

    # Check if the context file has cluster_master inside ucernvm section
    # 'sed' prints all lines  in the [ucernvm-*] section, grep greps the cluster_pin line
    local master_field=$( sed -n '/\[ucernvm-begin\]/,/\[ucernvm-end\]/p' "$CONTEXT_FILE" 2>/dev/null | grep "$CLUSTER_MASTER_CONTEXT_FIELD=" )

    # erase the first occurence of 'cluster_master=' from the grepped master line
    master_field=$( echo "$master_field" | sed -e "s/$CLUSTER_MASTER_CONTEXT_FIELD=//1" 2>/dev/null )
    if [ "x$master_field" = "xtrue" -o "x$master_field" = "xTrue" -o "x$master_field" = "x1" -o "x$master_field" = "xyes" ]; then
        master_contextualization
    else
        slave_contextualization
    fi

    # No matter the result, create the marker file, so it runs only on first boot
    create_ami_marker_file
}
contextualization # call the main contextualization function
